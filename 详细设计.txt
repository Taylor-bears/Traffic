老师好，原版的详细设计配有图片在word文档中，github无法打开word文件，所以我们暂且上传了一个仅有文字的版本。
我们会在最后全部设计好后，将word发给您，谢谢老师理解。

第七题：交通咨询系统
详细设计和编码
1、工程目录结构概览
├──── city.h                # 城市信息声明 
├──── city.cpp              # 城市信息实现 
├──── times.h               # 时间信息声明 
├──── times.cpp             # 时间信息实现 
├──── train.h               # 火车信息声明 
├──── train.cpp             # 火车信息实现
├──── fly.h                 # 飞机信息声明 
├──── fly.cpp               # 飞机信息实现
├──── vehicle.cpp           # 交通类信息实现
├──── vehicle.cpp           # 交通类信息实现
├──── Graph.h               # 图信息声明 
├──── Graph.cpp             # 图信息实现 
├──── Traffic.cpp           # 主界面实现

2、各类介绍
①城市类（city）
 
数据成员 三部分：1存储城市的一维向量、2存储城市与城市之间距离的无序映射、3存储城市与城市之间二维向量（2的进阶版）
 
函数成员 两部分：1 city构造函数（利用文件构造）、2 city默认构造函数
City.txt文件部分展示
设计概述：
通过一行一行读取文件的信息来存储至城市向量与无序映射中。
 
 
存储至城市向量（vector<string> name）：在常规的读取中，我们会遇到一个问题，就是城市名可能会重复，所以每次存储至城市名向量中，需要遍历看原向量中是否已含有该名称。
 
 
 
存储至无序映射（unordered_map<pair<string, string>, int, pair_hash, pair_equal> distance_map）：在无序映射中，键为两个城市名组成的二元组pair，值为两城市间的距离。但经过调试的过程中，我发现这里输入键无法找到他对应的值，通过查询资料，是因为无序映射中缺少pair和int的哈希函数和比较函数，所以需要自己补充哈希函数和比较函数来完善无需映射，经过此操作，通过键可以查找到值。
存储至距离二维向量（vector<vector<int>> dist）：此结构是我在后面构想如何显示两个城市之间的距离


②交通类（time）
 
数据成员 3部分：1天、2小时、3分钟
 
函数成员 9部分：1默认构造函数、2构造函数、3设置函数、4加时函数、5“=”重载函数、6“<”重载函数、7“+”重载函数、8“>”重载函数、9“==”重载函数
设计概述：
 
加时函数：由于分钟是这里的最小单位，所以我们以分钟作为参数，在原有时间上加上新的分钟得到新的时间，这其中就注意当分钟或者小时溢出的时候要向他的上一单位进位。
 
 
部分重载函数展示：利用C++类中重载符号的知识可解决


③交通类（vehicle）
前提说明：我们在设计中发现火车train类和飞机fly类两者的差别仅在于类型不同，其余都一样，我们将其统一为vehicle类，添加新成员type来区分两种交通工具。
 
数据成员 6部分：1类型（train或者fly）、2名称（火车或者飞机编号，如K117）、3出发时间、4消耗时间、5抵达时间、6费用
 
函数成员 5部分：1默认构造函数、2构造函数、3设置函数（更正信息）、4“=”重载函数、5“==”重载函数
重载函数已在上面的time类进行介绍，这里是类似的
 
 
Vehicle.txt文件部分展示


④图类（Graph）
 
为了后续数据处理，我们在Graph.h头文件定义了两种结构体PathStep（用于狄克斯特拉算法）和PathStep3（用于DFS深度探索）。其中PathStep包含了出发城市对应的数字、两城市间的交通工具类，PathStep3包含了出发城市对应的数字、抵达城市对应的城市、两城市间的交通工具类。
 
数据成员 4部分：1城市与序号对应的无序映射、2城市类（类的组合）、3城市数量、4交通信息邻接矩阵

 

 
   
函数成员 22部分：1构造函数（通过两个文件来构造）、2默认构造函数、3消耗时间转换函数
显示最快时间方案：4得到最小路径函数（不可更换交通工具类型，一直保持train或fly）、5 Dijkstra算法（对应4）、6得到最小路径函数（可更换交通工具类型）、7 Dijkstra算法（对应6）、8 DFS深度探索（直达情况下，即路途只能保持一种交通工具，名称也不可更换）、9 显示函数（对应8）
显示最少费用方案：10得到最小路径函数（不可更换交通工具类型，一直保持train或fly）、11 Dijkstra算法（对应10）、12得到最小路径函数（可更换交通工具类型）、13 Dijkstra算法（对应12）、14 DFS深度探索（直达情况下，即路途只能保持一种交通工具，名称也不可更换）、15 显示函数（对应14）
公共显示：16显示函数（可以指定type，对应5和10）、17显示函数（不指定type，对应7和13）
公共调用函数：18得到最优方案输入接口函数（对应Dijkstra）、19得到最优方案输入接口函数（对应DFS）
调试功能：20显示所有的城市与图中的各点信息函数（用于检查所有的城市是否录入，邻接矩阵每个点的交通信息是否全部显示）、21两文件城市名称校对函数（比较city.txt和vehicle.txt两个文件中出现的城市是否都一样）、22时间比较函数（已被时间类符号重载函数替代）
设计概述：
 
城市名与序号无序映射存储（unordered_map<string, int> traffic_map）：通过读取城市类中的name向量中的城市，使得每一个城市对应一个序号，这样的目的是因为，后面的交通信息存储基于邻接矩阵，而邻接矩阵的访问是通过[i][j]，两个int型来读取的。
 
 
 
 
交通信息邻接矩阵存储（vector<vector<vector<vehicle>>> edges）：我们在需求中说明了建立这样的邻接矩阵的原因，在存储的时候，我们严格按照vehicle.txt里面的形式来定义各个变量，通过文件读取，将每一行的交通信息读取到变量中，在依次存储到edges[i][j]向量中。
其中，我们为了与图的知识相对应，同时也为了后面处理问题的方便，我们将自己到自己的向量存储一个0的vehicle类，将没有路线连接的两个城市对应的向量存储一个INF的vehicle类。
 
时间转换函数：在vehicle.txt中交通工具消耗的时间是以4:24的形式存储，为了便于比较，我们设计了将其转换为double类型的函数。
补充说明：比较消耗时间这里我们没有采用time的重载，因为我们认为消耗时间日常是以小时和分钟展示，不用天数，所以可能会出现26:34的写法，如果使用原有的重载符号，就可能出错，原有的小时限制在24小时以内，所以我们直接将其统一转换为double型比较。
