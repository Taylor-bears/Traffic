老师好，原版的详细设计配有图片在word文档中，github无法打开word文件，所以我们暂且上传了一个仅有文字的版本。
我们会在最后全部设计好后，将word发给您，谢谢老师理解。

第七题：交通咨询系统
详细设计和编码
1、工程目录结构概览
├──── city.h                # 城市信息声明 
├──── city.cpp              # 城市信息实现 
├──── times.h               # 时间信息声明 
├──── times.cpp             # 时间信息实现 
├──── train.h               # 火车信息声明 
├──── train.cpp             # 火车信息实现
├──── fly.h                 # 飞机信息声明 
├──── fly.cpp               # 飞机信息实现
├──── vehicle.cpp           # 交通类信息实现
├──── vehicle.cpp           # 交通类信息实现
├──── Graph.h               # 图信息声明 
├──── Graph.cpp             # 图信息实现 
├──── Traffic.cpp           # 主界面实现

2、各类介绍
①城市类（city）
 
数据成员 三部分：1存储城市的一维向量、2存储城市与城市之间距离的无序映射、3存储城市与城市之间二维向量（2的进阶版）
 
函数成员 两部分：1 city构造函数（利用文件构造）、2 city默认构造函数
City.txt文件部分展示
设计概述：
通过一行一行读取文件的信息来存储至城市向量与无序映射中。
构造函数city(const string& file_path)：
 
 
存储至城市向量（vector<string> name）：在常规的读取中，我们会遇到一个问题，就是城市名可能会重复，所以每次存储至城市名向量中，需要遍历看原向量中是否已含有该名称。
 
 
 
存储至无序映射（unordered_map<pair<string, string>, int, pair_hash, pair_equal> distance_map）：在无序映射中，键为两个城市名组成的二元组pair，值为两城市间的距离。但经过调试的过程中，我发现这里输入键无法找到他对应的值，通过查询资料，是因为无序映射中缺少pair和int的哈希函数和比较函数，所以需要自己补充哈希函数和比较函数来完善无需映射，经过此操作，通过键可以查找到值。
存储至距离二维向量（vector<vector<int>> dist）：此结构是我在后面构想如何显示两个城市之间的距离


②交通类（time）
 
数据成员 3部分：1天、2小时、3分钟
 
函数成员 9部分：1默认构造函数、2构造函数、3设置函数、4加时函数、5“=”重载函数、6“<”重载函数、7“+”重载函数、8“>”重载函数、9“==”重载函数
设计概述：
加时函数void addMinutes(int minutes)：
 
由于分钟是这里的最小单位，所以我们以分钟作为参数，在原有时间上加上新的分钟得到新的时间，这其中就注意当分钟或者小时溢出的时候要向他的上一单位进位。
times operator+(const times& t) const：
 
bool operator>(const times& t) const：
 
部分重载函数展示：利用C++类中重载符号的知识可解决


③交通类（vehicle）
前提说明：我们在设计中发现火车train类和飞机fly类两者的差别仅在于类型不同，其余都一样，我们将其统一为vehicle类，添加新成员type来区分两种交通工具。
 
数据成员 6部分：1类型（train或者fly）、2名称（火车或者飞机编号，如K117）、3出发时间、4消耗时间、5抵达时间、6费用
 
函数成员 5部分：1默认构造函数、2构造函数、3设置函数（更正信息）、4“=”重载函数、5“==”重载函数
重载函数已在上面的time类进行介绍，这里是类似的
 
 
Vehicle.txt文件部分展示


④图类（Graph）
 
为了后续数据处理，我们在Graph.h头文件定义了两种结构体PathStep（用于狄克斯特拉算法）和PathStep3（用于DFS深度探索）。其中PathStep包含了出发城市对应的数字、两城市间的交通工具类，PathStep3包含了出发城市对应的数字、抵达城市对应的城市、两城市间的交通工具类。
 
数据成员 4部分：1城市与序号对应的无序映射、2城市类（类的组合）、3城市数量、4交通信息邻接矩阵

 

 
   
函数成员 28部分：1构造函数（通过两个文件来构造）、2默认构造函数、3消耗时间转换函数
显示最快时间方案：4得到最小路径函数（不可更换交通工具类型，一直保持train或fly）、5 Dijkstra算法（对应4）、6得到最小路径函数（可更换交通工具类型）、7 Dijkstra算法（对应6）、8 DFS深度探索（直达情况下，即路途只能保持一种交通工具，名称也不可更换）、9 显示函数（对应8）
显示最少费用方案：10得到最省钱路径函数（不可更换交通工具类型，一直保持train或fly）、11 Dijkstra算法（对应10）、12得到最省钱路径函数（可更换交通工具类型）、13 Dijkstra算法（对应12）、14 DFS深度探索（直达情况下，即路途只能保持一种交通工具，名称也不可更换）、15 显示函数（对应14）、16得到最省钱路径函数（不可更换交通工具类型，可限制时间）、17 Dijkstra算法（对应16）、18得到最省钱路径函数（可以更换交通工具类型，可限制时间）、19 Dijkstra算法（对应18）、20 DFS深度探索（直达情况下，可限制时间）、21、显示函数（对应20）
公共显示：22显示函数（可以指定type，对应5和10）、23显示函数（不指定type，对应7和13）
公共调用函数：24得到最优方案输入接口函数（对应Dijkstra）、25得到最优方案输入接口函数（对应DFS）
调试功能：26显示所有的城市与图中的各点信息函数（用于检查所有的城市是否录入，邻接矩阵每个点的交通信息是否全部显示）、27两文件城市名称校对函数（比较city.txt和vehicle.txt两个文件中出现的城市是否都一样）、28时间比较函数（已被时间类符号重载函数替代）
设计概述：
构造函数graph：
 
(const string& file_path1, const string& file_path2)：城市名与序号无序映射存储（unordered_map<string, int> traffic_map）：通过读取城市类中的name向量中的城市，使得每一个城市对应一个序号，这样的目的是因为，后面的交通信息存储基于邻接矩阵，而邻接矩阵的访问是通过[i][j]，两个int型来读取的。
 
 
 
 
交通信息邻接矩阵存储（vector<vector<vector<vehicle>>> edges）：我们在需求中说明了建立这样的邻接矩阵的原因，在存储的时候，我们严格按照vehicle.txt里面的形式来定义各个变量，通过文件读取，将每一行的交通信息读取到变量中，在依次存储到edges[i][j]向量中。
其中，我们为了与图的知识相对应，同时也为了后面处理问题的方便，我们将自己到自己的向量存储一个0的vehicle类，将没有路线连接的两个城市对应的向量存储一个INF的vehicle类。
时间转换函数bool timecheck
 
(times time1, times time2, int wait_hours)：在vehicle.txt中交通工具消耗的时间是以4:24的形式存储，为了便于比较，我们设计了将其转换为double类型的函数。
补充说明：比较消耗时间这里我们没有采用time的重载，因为我们认为消耗时间日常是以小时和分钟展示，不用天数，所以可能会出现26:34的写法，如果使用原有的重载符号，就可能出错，原有的小时限制在24小时以内，所以我们直接将其统一转换为double型比较。

最快路径
得到最小路径函数getmin（处理问题的关键）
 (vector<vehicle>& ve, times current_time, string type, string last_vehicle_name)：我们知道两个城市之间有多条路径，但我们在比较的时候只用从多条路径中选择一条最快的和其他最快的进行比较即可，我们这里以不允许更换交通工具类型为例。由于限定了类型，getmin函数有一个参数是type，寻找路径时只寻找相同type的；同时由于题目说了，如果更换交通工具，火车至少要等1小时，飞机至少要等2小时，所以getmin函数还需要有参数last_vehicle_name来记录上一次的交通名称，从而来筛选满足中转等待时间下的可行路径，last_vehicle_name决定了这一次的等待时间wait_time，通过current_time+wait_time是否小于ve.time1来判断是否可行（下一次的出发时间必须大于上一次的抵达时间加上等待时间），最后符合条件的，比较它们之间的抵达时间，也就是time2来选出最优路径。
狄克斯特拉算法Time_Dijkstra2


(int v, int n, times current_time)：我们对课本原有的狄克斯特拉算法进行了改进。dist用于存储比较的筹码，也就是各工具的抵达时间time2；path存储的是路径上的点，为了便于在输出的时候同时输出工具的各个信息，我们将PathStep作为path的类型，记录点的同时，也记录vehicle的信息；visited以bool为类型，作用与原来的S类似，bool的true与false更能直观地反映该点是否已访问。
通过getmin选出两点间最小的后，和之前的最小路径进行比较，一一比较得到从起点到该点的最小路径，将最小的点的序号与vehicle信息一同存入path中。
显示函数void display
 
 
(vector<times>& dist, vector<PathStep>& path, vector<bool>& S, int v, int n, string type)：在Dijkstra得到的path[i]存储的是v到i最快路径上的前一个点，需要不断地回溯直到找到起始点，得到的就是完整的最短路径。课本用的是将path的数据存储到apath的向量中，再倒着输出。这里我们改进，使用栈来复制path，一开始全部push，后依次pop即可，同时由于我先定义的PathStep中仅存储了起点城市，没有存储终点城市（在后面的DFS中为了简化问题，我定义了新的PathStep3中就存储了终点城市），所以为了输出终点城市，我们还定义了城市名的stack，在输出vehicle的同时，输出城市的stack即可同时输出每一段的起始点、终点、交通工具的各个信息。
可换工具的得到最小路径函数getmin2
 
(vector<vehicle>& ve, times current_time, string last_vehicle_type, string last_vehicle_name)：与getmin是类似的，不同的就是，getmin2删除了前后交通类型限定的限制。

最省钱路径
得到最省钱路径函数getminmoney
 
(vector<vehicle>& ve, times current_time, string type, string last_vehicle_name)：这里的函数和getmin是类似的，在满足每个点时间要求的前提下，比较的筹码从每一次的到达时间改为每一段的费用。
得到最省钱路径函数getminmoney_limit
 
(vector<vehicle>& ve, times current_time, string type, string last_vehicle_name, int extra_hour):
设计背景：在上述的getmoney函数中已经能找到每一次的最省钱路径，但我设想了一种情况，我打算的出发日期是7月4号9点0分，但他给出的最省钱的路径是在7月16号12点0分，就是说：他确实给出了最便宜的可行路径，但是它的出发时间与预期的相差过远，这在日常生活中也是不符合实际的，所以我又添加了可限制时间的最省钱路径，游客可以输入接受的最大的天数，比如游客输入2天，那么最省钱路径挑选时，它的第一段的时间一定是要在7月4号9点0分与7月6号9点0分之间的，这样可以给出更加合理的最省钱路径。
补充说明：最快路径不需要考虑时间限制，因为他给出的一定是最快的路径，最快的就是vehicle.txt能实现的最快路径，不会因为时间是否有限制而找到更快的路径。
设计思路：在原有的getmin函数进行修改，当上一交通工具名称为空时，说明是第一次选择，此时对交通工具的时间进行两次限制即可。

直达路径
DFS函数：
 
设计背景：我们在原有题目拓展了需求，就是这个游客可能不愿意接受中转，只接受直达的情况。我原本设想的是，在原有的Dijkstra基础上改进一下，加上同名称的限制，但是我也发现一个问题，第一次选出来的最快的不一定最后是最快的，因为可能会出现这样的情况：假设K112与K114走的是一样的路线、经过一样的城市，两者的区别是K112最开始一段的到达时间最短，而K114最后一段的到达时间最短，但整段行程的时间快慢应当是取决于最后一段的时间，而利用Dijkstra选出了K112后就限制了后面的所有工具名称，使得无法真正找到最快的路径，所以我们决定用DFS找到所有可能的情况，再在这些情况中选出最快的即可（由于同名的限制，DFS查找出来的路径不会过多）
设计思路：由于同名限制，到达某一个站点后，不需要考虑等待时间。这里的DFS仍然可以选择交通类型，不满足类型的工具不考虑。每个路径的名称由他第一次的交通名称决定，所以每一段都需要传递VehicleName。



一开始并没有名称，所以name为“”（空），如果name为空，则VehicleName为此时vehicle的name，也就是第一次交通工具的name，如果不为空了，那么之后传递的都为vehicleName也就是第一次的vehicle.name.

如果path非空，vehicle.name不为空，且vehicle.name不与之前的VehicleName相同，则跳过。






这是DFS的递归出口，每个可行路径会依次更新bestPath和bestTime，选出bestTime最小的bestPath。
显示函数：
 
上个问题采用的是PathStep，仅存储了出发地，这里我们采用PathStep3，同时保存出发地和目的地，在调用DFS时，需要将VehicleName设置为空（第一次为空）。
最省钱直达路径DFS2函数：
 
这里与原有的DFS函数是类似的，区别在于递归出口出的比较，DFS只用比较每个path最后更新的bestTime即可，而省钱需要将每一段的费用累计后再进行比较。
可限制最省钱直达路径DFS2_limit函数：
 
有时间限制时，当path为空也就是遍历最开始路径时，时间需要满足两个限制。
